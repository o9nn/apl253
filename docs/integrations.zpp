â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Z++ FORMAL SPECIFICATION: PATTERN LANGUAGE INTEGRATION CONTRACTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

This specification defines external integration contracts for file I/O,
markdown parsing, JSON schema validation, and OpenCog Atomese generation.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 1: FILE SYSTEM INTEGRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ FileHandle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Abstract handle to a file in the filesystem                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  FileHandle
    path: String
    exists: ğ”¹
    readable: ğ”¹
    writable: ğ”¹
    size: â„•
    last_modified: â„•
  where
    /* Path must be non-empty */
    path â‰  ""
    
    /* If file exists, it has positive size */
    exists â‡’ size > 0
    
    /* Can't read or write non-existent files */
    Â¬exists â‡’ Â¬readable âˆ§ Â¬writable


â”Œâ”€ ReadMarkdownFile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Read markdown file from filesystem                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ReadMarkdownFile
    Î”FileSystemState
    filepath?: String
    content!: String
    success!: ğ”¹
    error_msg!: String
  where
    /* File must exist and be readable */
    let handle = GetFileHandle(filepath?) in
    
    /* Pre-condition: file must exist and be markdown */
    filepath? ends_with ".md" âˆ§
    handle.exists âˆ§ handle.readable
    
    /* Read file content */
    success! â‡’ (
      content! = ReadFileContent(filepath?) âˆ§
      content! â‰  "" âˆ§
      error_msg! = ""
    )
    
    /* Handle errors */
    Â¬success! â‡’ (
      content! = "" âˆ§
      error_msg! â‰  "" âˆ§
      error_msg! âˆˆ {"File not found", "Permission denied", 
                    "Read error", "Not a markdown file"}
    )
    
    /* Update filesystem state */
    success! â‡’
      filesystem_state'.markdown_files = 
        filesystem_state.markdown_files âŠ•
        {filepath? â†¦ (content!, CurrentTimestamp())}


â”Œâ”€ WriteJSONFile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Write JSON content to filesystem                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  WriteJSONFile
    Î”FileSystemState
    filepath?: String
    content?: String
    success!: ğ”¹
    error_msg!: String
  where
    /* File must have .json extension */
    filepath? ends_with ".json"
    
    /* Content must be valid JSON */
    ValidJSON(content?)
    
    /* Write to file */
    success! â‡’ (
      WriteFileContent(filepath?, content?) âˆ§
      error_msg! = ""
    )
    
    /* Handle errors */
    Â¬success! â‡’ (
      error_msg! â‰  "" âˆ§
      error_msg! âˆˆ {"Permission denied", "Disk full", 
                    "Invalid path", "Write error"}
    )
    
    /* Update filesystem state */
    success! â‡’
      filesystem_state'.json_files = 
        filesystem_state.json_files âŠ•
        {filepath? â†¦ (content?, CurrentTimestamp())}


â”Œâ”€ ReadDirectory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ List all files in a directory                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ReadDirectory
    ÎFileSystemState
    dirpath?: String
    files!: seq String
    success!: ğ”¹
  where
    /* Directory must exist */
    DirectoryExists(dirpath?)
    
    /* List all files */
    success! â‡’ (
      files! = âŸ¨f | f âˆˆ ListFiles(dirpath?)âŸ© âˆ§
      âˆ€ f âˆˆ files! â€¢ f â‰  ""
    )
    
    Â¬success! â‡’ files! = âŸ¨âŸ©

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 2: MARKDOWN PARSING INTEGRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ ParseMarkdownPattern â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Parse a pattern from APL markdown format                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ParseMarkdownPattern
    content?: String
    pattern!: Pattern
    success!: ğ”¹
    parse_errors!: seq String
  where
    /* Content must not be empty */
    content? â‰  ""
    
    /* Extract pattern components using regex patterns */
    let number_match = ExtractPatternNumber(content?) in
    let name_match = ExtractPatternName(content?) in
    let context_match = ExtractContext(content?) in
    let problem_match = ExtractProblemSummary(content?) in
    let details_match = ExtractProblemDetails(content?) in
    let solution_match = ExtractSolution(content?) in
    
    success! â‡’ (
      pattern!.number = number_match âˆ§
      pattern!.name = name_match âˆ§
      pattern!.context = context_match âˆ§
      pattern!.problem_summary = problem_match âˆ§
      pattern!.problem_details = details_match âˆ§
      pattern!.solution = solution_match âˆ§
      pattern!.asterisks = CountAsterisks(content?) âˆ§
      pattern!.preceding_patterns = ExtractPrecedingPatterns(content?) âˆ§
      pattern!.following_patterns = ExtractFollowingPatterns(content?) âˆ§
      parse_errors! = âŸ¨âŸ©
    )
    
    /* Collect parse errors */
    Â¬success! â‡’ (
      parse_errors! â‰  âŸ¨âŸ© âˆ§
      (number_match = âˆ… â‡’ 
        parse_errors! = parse_errors! âŒ¢ âŸ¨"Pattern number not found"âŸ©) âˆ§
      (name_match = "" â‡’ 
        parse_errors! = parse_errors! âŒ¢ âŸ¨"Pattern name not found"âŸ©)
    )


â”Œâ”€ ParseArchetypalMarkdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Parse an archetypal pattern with domain mappings                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ParseArchetypalMarkdown
    content?: String
    pattern!: ArchetypalPattern
    success!: ğ”¹
    parse_errors!: seq String
  where
    /* Content must contain archetypal pattern section */
    content? contains "## Archetypal Pattern"
    
    /* Extract components */
    let id_match = ExtractPatternID(content?) in
    let name_match = ExtractPatternName(content?) in
    let archetypal_text = ExtractArchetypalPattern(content?) in
    let original_text = ExtractOriginalTemplate(content?) in
    let placeholders = ExtractPlaceholders(archetypal_text) in
    let mappings = ExtractDomainMappings(content?) in
    
    success! â‡’ (
      pattern!.pattern_id = id_match âˆ§
      pattern!.name = name_match âˆ§
      pattern!.archetypal_pattern = archetypal_text âˆ§
      pattern!.original_template = original_text âˆ§
      pattern!.placeholders = placeholders âˆ§
      pattern!.domain_mappings = mappings âˆ§
      parse_errors! = âŸ¨âŸ© âˆ§
      
      /* Verify all placeholders have mappings */
      âˆ€ ph âˆˆ placeholders â€¢ ph âˆˆ dom mappings
    )
    
    /* Collect parse errors */
    Â¬success! â‡’ parse_errors! â‰  âŸ¨âŸ©


â”Œâ”€ ExtractPlaceholders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Extract all {{placeholder}} occurrences from text                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ExtractPlaceholders
    text?: String
    placeholders!: seq PlaceholderName
  where
    /* Find all {{...}} patterns */
    let matches = RegexFindAll("{{([^}]+)}}", text?) in
    
    /* Extract placeholder names */
    placeholders! = âŸ¨ConvertToPlaceholderName(m) | m âˆˆ matchesâŸ©
    
    /* Remove duplicates while preserving order */
    âˆ€ i, j: â„• | i < j âˆ§ i, j < #placeholders! â‡’
      placeholders![i] = placeholders![j] â‡’ 
        âˆƒ k: â„• â€¢ k < i âˆ§ placeholders![k] = placeholders![i]


â”Œâ”€ ExtractDomainMappings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Extract domain mappings from markdown format                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ExtractDomainMappings
    content?: String
    mappings!: PlaceholderName â‡¶ DomainMapping
  where
    /* Find Domain Placeholders section */
    content? contains "## Domain Placeholders"
    
    /* Extract each placeholder mapping line */
    let mapping_lines = ExtractSection(content?, 
                          "## Domain Placeholders",
                          "## Original Template") in
    
    /* Parse each line: `{{ph}}` â†’ Physical: val | Social: val | ... */
    âˆ€ line âˆˆ mapping_lines â€¢
      let ph = ExtractPlaceholderFromLine(line) in
      let physical = ExtractDomainValue(line, "Physical") in
      let social = ExtractDomainValue(line, "Social") in
      let conceptual = ExtractDomainValue(line, "Conceptual") in
      let psychic = ExtractDomainValue(line, "Psychic") in
      
      mappings! = mappings! âŠ• {ph â†¦ DomainMapping where
        .placeholder = ph âˆ§
        .physical = physical âˆ§
        .social = social âˆ§
        .conceptual = conceptual âˆ§
        .psychic = psychic âˆ§
        .description = "Domain mappings for " âŒ¢ ph}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 3: JSON SCHEMA VALIDATION INTEGRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ JSONSchema â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Abstract representation of a JSON Schema                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  JSONSchema
    schema_uri: String
    title: String
    definitions: String â‡¶ SchemaDefinition
    properties: String â‡¶ PropertySchema
    required: â„™ String
  where
    /* Schema URI must be valid */
    schema_uri = "http://json-schema.org/draft-07/schema#"
    
    /* Required properties must be defined */
    required âŠ† dom properties


â”Œâ”€ ValidateAgainstSchema â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Validate JSON content against a schema                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ValidateAgainstSchema
    ÎSchemaRegistry
    json_content?: String
    schema_name?: String
    valid!: ğ”¹
    errors!: seq String
  where
    /* JSON content must be parseable */
    ValidJSON(json_content?)
    
    /* Schema must exist */
    schema_name? âˆˆ {"pattern_schema", "archetypal_schema"}
    
    let schema = (schema_name? = "pattern_schema" â‡’ 
                   schema_registry.pattern_schema,
                 schema_registry.archetypal_schema) in
    
    /* Validate structure */
    let validation_result = JSONSchemaValidator(json_content?, schema) in
    
    valid! âŸº validation_result.valid
    
    /* Collect validation errors */
    Â¬valid! â‡’ (
      errors! = validation_result.errors âˆ§
      âˆ€ err âˆˆ errors! â€¢ err â‰  ""
    )
    
    valid! â‡’ errors! = âŸ¨âŸ©


â”Œâ”€ SerializeToJSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Serialize data structure to JSON format                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  SerializeToJSON[T]
    data?: T
    schema?: JSONSchema
    json_output!: String
    success!: ğ”¹
  where
    /* Serialize data to JSON string */
    let json_str = JSONEncoder(data?) in
    
    /* Validate against schema */
    let valid = ValidatesAgainstSchema(json_str, schema?) in
    
    success! âŸº valid âˆ§ ValidJSON(json_str)
    
    success! â‡’ json_output! = json_str
    
    Â¬success! â‡’ json_output! = ""

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 4: OPENCOG ATOMESE INTEGRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ AtomType â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Types of atoms in OpenCog's Atomese representation                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  AtomType ::= 
    ConceptNode | PredicateNode | 
    InheritanceLink | MemberLink | EvaluationLink |
    ListLink | AndLink | OrLink


â”Œâ”€ Atom â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Basic atom structure in OpenCog Atomese                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Atom
    atom_type: AtomType
    name: String
    children: seq Atom
    truth_value: (â„ Ã— â„)  /* (strength, confidence) */
  where
    /* Name must be non-empty for concept/predicate nodes */
    atom_type âˆˆ {ConceptNode, PredicateNode} â‡’ name â‰  ""
    
    /* Links must have children */
    atom_type âˆ‰ {ConceptNode, PredicateNode} â‡’ children â‰  âŸ¨âŸ©
    
    /* Truth value must be in valid range */
    let (strength, confidence) = truth_value in
    strength â‰¥ 0.0 âˆ§ strength â‰¤ 1.0 âˆ§
    confidence â‰¥ 0.0 âˆ§ confidence â‰¤ 1.0


â”Œâ”€ GenerateAtomesePattern â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Generate Atomese representation for an APL pattern                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  GenerateAtomesePattern
    ÎPatternRegistry
    pattern_number?: PatternNumber
    atoms!: seq Atom
    scheme_code!: String
    success!: ğ”¹
  where
    /* Pattern must exist */
    pattern_number? âˆˆ dom pattern_registry.patterns
    
    let p = pattern_registry.patterns(pattern_number?) in
    
    /* Create concept node for pattern */
    let pattern_node = Atom where
      .atom_type = ConceptNode âˆ§
      .name = "Pattern-" âŒ¢ ToString(p.number) âˆ§
      .children = âŸ¨âŸ© âˆ§
      .truth_value = (1.0, 1.0)
    
    /* Create evaluation for pattern name */
    let name_predicate = Atom where
      .atom_type = PredicateNode âˆ§
      .name = "has-name" âˆ§
      .children = âŸ¨âŸ©
    
    let name_eval = Atom where
      .atom_type = EvaluationLink âˆ§
      .children = âŸ¨name_predicate, pattern_node, 
                    ConceptNode(p.name)âŸ©
    
    /* Create inheritance links for category */
    let category = category_registry.category_index(pattern_number?) in
    let category_node = ConceptNode("Category-" âŒ¢ category)
    
    let category_link = Atom where
      .atom_type = InheritanceLink âˆ§
      .children = âŸ¨pattern_node, category_nodeâŸ©
    
    /* Generate atoms */
    atoms! = âŸ¨pattern_node, name_eval, category_linkâŸ©
    
    /* Convert to Scheme code */
    scheme_code! = ConvertToScheme(atoms!)
    
    success! âŸº ValidScheme(scheme_code!)


â”Œâ”€ GenerateAtomeseArchetypal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Generate Atomese for archetypal pattern with domain variants               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  GenerateAtomeseArchetypal
    ÎArchetypalRegistry
    pattern_id?: String
    atoms!: seq Atom
    scheme_code!: String
    success!: ğ”¹
  where
    /* Pattern must exist */
    pattern_id? âˆˆ dom archetypal_registry.patterns
    
    let ap = archetypal_registry.patterns(pattern_id?) in
    
    /* Create concept node for archetypal pattern */
    let archetypal_node = ConceptNode("Archetypal-" âŒ¢ pattern_id?)
    
    /* Create nodes for each domain variant */
    let physical_node = ConceptNode(pattern_id? âŒ¢ "-Physical")
    let social_node = ConceptNode(pattern_id? âŒ¢ "-Social")
    let conceptual_node = ConceptNode(pattern_id? âŒ¢ "-Conceptual")
    let psychic_node = ConceptNode(pattern_id? âŒ¢ "-Psychic")
    
    /* Create inheritance links */
    let physical_link = InheritanceLink(physical_node, archetypal_node)
    let social_link = InheritanceLink(social_node, archetypal_node)
    let conceptual_link = InheritanceLink(conceptual_node, archetypal_node)
    let psychic_link = InheritanceLink(psychic_node, archetypal_node)
    
    /* Generate atoms */
    atoms! = âŸ¨archetypal_node, 
              physical_node, physical_link,
              social_node, social_link,
              conceptual_node, conceptual_link,
              psychic_node, psychic_linkâŸ©
    
    /* Convert to Scheme */
    scheme_code! = ConvertToScheme(atoms!)
    
    success! âŸº ValidScheme(scheme_code!)


â”Œâ”€ WriteAtomeseFile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Write Atomese representation to Scheme file                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  WriteAtomeseFile
    Î”FileSystemState
    filepath?: String
    scheme_code?: String
    success!: ğ”¹
    error_msg!: String
  where
    /* File must have .scm extension */
    filepath? ends_with ".scm"
    
    /* Scheme code must be valid */
    ValidScheme(scheme_code?)
    
    /* Write to file */
    success! â‡’ (
      WriteFileContent(filepath?, scheme_code?) âˆ§
      error_msg! = ""
    )
    
    Â¬success! â‡’ error_msg! â‰  ""

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 5: EXTERNAL HELPER FUNCTIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ ValidJSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Check if string is valid JSON                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ValidJSON: String â†’ ğ”¹
  
  âˆ€ s: String â€¢
    ValidJSON(s) âŸº 
      s â‰  "" âˆ§ 
      JSONParser(s) â‰  âˆ… âˆ§
      Â¬ParseError(JSONParser(s))


â”Œâ”€ ValidScheme â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Check if string is valid Scheme code                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ValidScheme: String â†’ ğ”¹
  
  âˆ€ s: String â€¢
    ValidScheme(s) âŸº 
      s â‰  "" âˆ§ 
      BalancedParentheses(s) âˆ§
      SchemeParser(s) â‰  âˆ… âˆ§
      Â¬ParseError(SchemeParser(s))


â”Œâ”€ CurrentTimestamp â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Get current Unix timestamp                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  CurrentTimestamp: â„•
  
  CurrentTimestamp â‰¥ 0


â”Œâ”€ ApplySubstitutions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Apply placeholder substitutions to text                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ApplySubstitutions: String Ã— (PlaceholderName â‡¶ String) â†’ String
  
  âˆ€ text: String, subs: PlaceholderName â‡¶ String â€¢
    let result = text in
    âˆ€ ph âˆˆ dom subs â€¢
      result = ReplaceAll(result, "{{" âŒ¢ ph âŒ¢ "}}", subs(ph))
    
    ApplySubstitutions(text, subs) = result

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 6: INTEGRATION INVARIANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ FileSystemConsistency â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Invariant: Generated JSON files must be newer than source markdown         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  FileSystemConsistency
    ÎFileSystemState
  where
    âˆ€ json_path âˆˆ dom filesystem_state.json_files â€¢
      âˆ€ md_path âˆˆ filesystem_state.file_dependencies(json_path) â€¢
        let (_, json_time) = filesystem_state.json_files(json_path) in
        let (_, md_time) = filesystem_state.markdown_files(md_path) in
        json_time â‰¥ md_time


â”Œâ”€ SchemaValidationConsistency â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Invariant: All cached validation results are current                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  SchemaValidationConsistency
    ÎSchemaRegistry
    ÎValidationState
  where
    /* Patterns with validation results must exist */
    âˆ€ pn âˆˆ validation_state.patterns_validated â€¢
      ValidPattern(pattern_registry.patterns(pn))
    
    /* Archetypes with validation results must exist */
    âˆ€ pid âˆˆ validation_state.archetypes_validated â€¢
      ValidArchetypalPattern(archetypal_registry.patterns(pid))

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 END OF INTEGRATIONS SPECIFICATION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
